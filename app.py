from flask import Flask, render_template, request, jsonify, send_file
from sklearn.impute import SimpleImputer
import subprocess
import os
import csv
import pickle
import pandas as pd
import json
import re

app = Flask(__name__)

# Definisikan path untuk folder input, output, model, dan nama-nama file
input_path = 'pdf_in'
output_path = 'pdf_out'
model_path = 'models'
renamed_pdf = 'input.pdf'
metadata_csv = 'output_metadata.csv'
metadata_json = 'output_metadata.json'

csv_output = os.path.join(output_path, metadata_csv)
json_output = os.path.join(output_path, metadata_json)

model = "new_rf.pkl"


@app.route('/')
def index():
    return render_template('index.html')


@app.route('/about.html')
def about():
    return render_template('about.html')


# Fungsi ekstraksi metadata PDF
def extract_metadata(pdf_path, filename):
    result = subprocess.check_output(
        ['python', 'pdfid/pdfid.py', pdf_path], text=True, cwd=os.getcwd())

    metadata = {
        "PDFIDVersion": "PDFiD 0.2.8",
        "FileName": filename
    }

    for line in result.strip().split('\n'):
        key, value = line.strip().split(None, 1)
        if not key.startswith("PDFiD, "):
            if key == "PDF":
                key = "Header"
                value = value.split(": ")[1]
            elif value.startswith("> 2^24"):
                value = value.lstrip("> 2^24")
            elif key.startswith("/"):
                key = key[1:]

            key = {
                "obj": "Obj",
                "endobj": "Endobj",
                "stream": "Stream",
                "endstream": "Endstream",
                "xref": "Xref",
                "trailer": "Trailer",
                "startxref": "StartXref",
                "Page": "PageNo",
                "JavaScript": "Javascript",
                "AcroForm": "Acroform",
                "/Colors": "Colors",
            }.get(key, key)

            metadata[key] = int(value) if value.isnumeric() else value

    metadata.pop("PDFiD", None)

    return metadata


# Fungsi untuk menyimpan metadata ke dalam file CSV
def save_metadata_to_csv(metadata, output_path):
    with open(output_path, 'w', newline='') as output_file:
        csv_writer = csv.writer(output_file, delimiter=',')
        csv_writer.writerow(metadata.keys())
        csv_writer.writerow(metadata.values())


# Fungsi untuk menyimpan metadata ke dalam file JSON
def save_metadata_to_json(metadata, output_path):
    with open(output_path, 'w') as json_file:
        json.dump(metadata, json_file, indent=4)


@app.route('/predict', methods=['POST'])
def predict():
    if 'pdf_file' not in request.files:
        return jsonify({'error': 'No file part'})

    if not os.path.exists(input_path):
        os.makedirs(input_path)

    if not os.path.exists(output_path):
        os.makedirs(output_path)

    pdf_file = request.files['pdf_file']

    if pdf_file.filename == '':
        return jsonify({'error': 'No selected file'})

    if pdf_file and pdf_file.filename.endswith('.pdf'):
        try:
            # Simpan file PDF yang diunggah
            ori_filename = pdf_file.filename
            pdf_file.filename = renamed_pdf

            pdf_path = os.path.join(input_path, pdf_file.filename)
            pdf_file.save(pdf_path)

            # Ekstrak metadata dari file PDF
            metadata = extract_metadata(pdf_path, ori_filename)

            # Simpan hasil ekstraksi metadata ke dalam format CSV dan JSON
            save_metadata_to_csv(metadata, csv_output)
            save_metadata_to_json(metadata, json_output)

            # Load Model
            with open(os.path.join(model_path, model), 'rb') as model_file:
                loaded_model = pickle.load(model_file)

            # Buat DataFrame dari metadata
            df = pd.DataFrame([metadata])

            # Hapus kolom yang tidak digunakan jika ada
            unused_columns = ['URI', 'PDFIDVersion', 'FileName']
            df.drop(columns=unused_columns, inplace=True, errors='ignore')

            if 'Header' in df.columns:
                # Hapus karakter "\t" dari awal dan karakter " dari akhir
                df['Header'] = df['Header'].str.strip('\t"')

                # Buat kamus pemetaan
                header_mapping = {
                    f"%PDF-1.{i}": i for i in range(8)
                }

                # Map 'Header' values to numerical categories
                df['Header'] = df['Header'].map(header_mapping).fillna(9999999)

                # Define a function to replace non-integer data with 9999999
                def replace_non_integer_data(value):
                    try:
                        return int(value)
                    except ValueError:
                        return 9999999

                # Columns to convert
                columns_to_convert = ['Obj', 'Endobj', 'Stream',
                                      'Endstream', 'Xref', 'Trailer', 'StartXref']

                # Apply the conversion function to selected columns
                df[columns_to_convert] = df[columns_to_convert].map(
                    replace_non_integer_data)

                # Replace unusual data values with 9999999 in string-like columns
                for column in df.columns:
                    if df[column].dtype == 'object':
                        unique_values = df[column].value_counts()
                        unusual_data = [item for item in unique_values.index if re.match(
                            r'\S+\(\S+\)|>', item)]
                        df[column] = df[column].replace(unusual_data, 9999999)

                # Misalnya, menggantikan missing values dengan mean
                imputer = SimpleImputer(strategy='mean')
                df[df.columns] = imputer.fit_transform(df)

                # Lakukan prediksi
                prediction = loaded_model.predict(df)

                # Klasifikasi prediksi sebagai "Malicious" atau "Benign"
                result = "Malicious" if 1 in prediction else "Benign"

                return jsonify({'result': result, 'metadata': metadata})
            else:
                return jsonify({'error': 'Metadata does not contain "Header" column'})
        except subprocess.CalledProcessError as e:
            return jsonify({'error': f'Error extracting metadata: {str(e)}'})
        except Exception as e:
            return jsonify({'error': f'Error: {str(e)}'})
    else:
        return jsonify({'error': 'Invalid file format'})


@app.route('/download-csv')
def download_csv():
    return send_file(csv_output, mimetype='text/csv', as_attachment=True)


@app.route('/download-json')
def download_json():
    return send_file(json_output, mimetype='application/json', as_attachment=True)


if __name__ == '__main__':
    app.run(host='127.0.0.1', port=5000, debug=True)
